6. 배열

- 여러개의 값을 메모리에 하나의 물리적인 공간으로 생성(메모리 > 힙)하고, 하나의 변수(메모리 > 스택)로 참조한다.
- 같은 종류의 데이터 타입만 저장이 가능하다.
- Runtime Area 영역의 Heap에 생성된다.
- 배열의 데이터는 연속적인 주소값을 가지게 된다.

(1) 배열의 선언
- 형식 : 데이터타입[] 변수명; 데이터타입 변수명[]; (동시에 대괄호 들어가면 에러)
- 형식 : 데이터타입[] 변수명 = {데이터1, 데이터2, 데이터3 ...}; (데이터 값을 알고 있는 경우)
예) String[] names; int scores[];

(2) 데이터 저장소 생성 및 할당
- 형식 : 데이터타입[] 변수명 = new int[크기(숫자)];
- 형식 : 데이터타입[] 변수명 = {데이터1, 데이터2, 데이터3 ...}; (정확한 데이터를 알고 있는 경우 {})
예) String[] names = new String;
예) int[] names = new int;
<br> <br>
=====================================================================================


1. 배열의 기본 개념과 필요성
배열이란?
배열(Array)은 동일한 데이터 타입의 여러 요소를 연속된 메모리 공간에 저장하는 자료구조입니다. 자바에서 배열은 객체로 취급되며, 힙(Heap) 메모리에 저장됩니다.

배열의 필요성
java
// 비효율적인 방법 - 개별 변수 사용
int score1 = 90;
int score2 = 80; 
int score3 = 70;
// ... 50개 변수 선언

// 효율적인 방법 - 배열 사용
int[] scores = new int[50];
배열의 장점:

같은 타입의 대량 데이터를 효율적으로 관리

반복문을 활용한 일괄 처리 가능

메모리 사용량 최적화

인덱스를 통한 빠른 데이터 접근

2. 배열 선언과 초기화
2.1 배열 선언 방법
java
// 권장 방법
int[] array1;
String[] names;

// 가능하나 권장하지 않음 
int array2[];
String names2[];
주요 특징:

타입[] 변수명 형태가 가독성 측면에서 권장됨

선언만으로는 메모리 할당되지 않음

배열 변수는 참조값(주소)만 저장

2.2 배열 초기화 방법
방법 1: 크기 지정 후 초기화
java
int[] numbers = new int[5];        // 기본값 0으로 초기화
String[] names = new String[3];    // 기본값 null로 초기화
boolean[] flags = new boolean[2];  // 기본값 false로 초기화
방법 2: 리터럴 초기화
java
int[] numbers = {1, 2, 3, 4, 5};
String[] names = {"홍길동", "이순신", "김유신"};

// 선언과 초기화 분리시
int[] numbers;
numbers = new int[]{1, 2, 3, 4, 5};
방법 3: Arrays 클래스 활용
java
import java.util.Arrays;

int[] numbers = new int[5];
Arrays.fill(numbers, 100);  // 모든 요소를 100으로 초기화
2.3 데이터 타입별 기본값
데이터 타입	기본값
byte, short, int, long	0
float, double	0.0
boolean	false
char	'\u0000' (null 문자)
참조형 (String, Object 등)	null
3. 배열 메모리 구조
3.1 기본형 배열 vs 참조형 배열
기본형 배열 메모리 구조
java
int[] numbers = {10, 20, 30};
스택: numbers 변수 (배열 객체의 주소 저장)

힙: 실제 배열 객체 (10, 20, 30 저장)

참조형 배열 메모리 구조
java
String[] names = {"홍길동", "이순신"};
스택: names 변수 (배열 객체의 주소)

힙: String 배열 객체 (각 String 객체의 주소들 저장)

문자열 상수 풀/힙: 실제 문자열 객체들

3.2 Call by Value vs Call by Reference
java
// 기본형 - Call by Value (값 복사)
int a = 10;
int b = a;  // 값 10이 복사됨

// 참조형 - Call by Reference (주소 복사)
int[] arr1 = {1, 2, 3};
int[] arr2 = arr1;  // 같은 배열 객체를 참조
4. 배열 사용과 순회
4.1 일반 for문
java
int[] numbers = {1, 2, 3, 4, 5};

for (int i = 0; i < numbers.length; i++) {
    System.out.println("numbers[" + i + "] = " + numbers[i]);
}
장점: 인덱스 제어 가능, 역순 순회 가능, 요소 수정 가능

4.2 향상된 for문 (for-each)
java
int[] numbers = {1, 2, 3, 4, 5};

for (int number : numbers) {
    System.out.println(number);
}
장점: 코드 간결성, 가독성 향상
단점: 인덱스 접근 불가, 요소 수정 제한

4.3 성능 비교
ArrayList: 일반 for문이 더 빠름

LinkedList: for-each문이 더 빠름

배열: 두 방식 모두 비슷한 성능

5. 배열 복사
5.1 for문을 이용한 복사
java
int[] original = {1, 2, 3};
int[] copy = new int[3];

for (int i = 0; i < original.length; i++) {
    copy[i] = original[i];
}
5.2 System.arraycopy()
java
int[] original = {1, 2, 3};
int[] copy = new int[3];

System.arraycopy(original, 0, copy, 0, original.length);
// arraycopy(원본, 원본시작위치, 복사본, 복사본시작위치, 복사길이)
특징: 네이티브 메서드로 성능 최적화

5.3 Arrays.copyOf()
java
import java.util.Arrays;

int[] original = {1, 2, 3};
int[] copy = Arrays.copyOf(original, original.length);

// 크기 확장도 가능
int[] extended = Arrays.copyOf(original, 5);  // [1, 2, 3, 0, 0]
특징: 코드 간결성, 내부적으로 System.arraycopy() 사용

5.4 Arrays.copyOfRange()
java
int[] original = {1, 2, 3, 4, 5};
int[] partial = Arrays.copyOfRange(original, 1, 4);  // [2, 3, 4]
6. 2차원 배열
6.1 2차원 배열 개념
2차원 배열은 배열의 배열로, 행(row)과 열(column)을 가지는 테이블 형태의 자료구조입니다.

6.2 선언 및 초기화
정형 배열 (모든 행의 길이가 동일)
java
// 방법 1: 크기 지정
int[][] matrix = new int[3][3];

// 방법 2: 리터럴 초기화
int[][] matrix = {
    {10, 20, 30},
    {40, 50, 60},
    {70, 80, 90}
};
가변형 배열 (행마다 다른 길이)
java
int[][] jagged = new int[3][];
jagged[0] = new int[2];  // 첫 번째 행: 2개 요소
jagged[1] = new int[4];  // 두 번째 행: 4개 요소
jagged[2] = new int[1];  // 세 번째 행: 1개 요소

// 리터럴 초기화
int[][] jagged2 = {
    {1, 2},
    {3, 4, 5, 6},
    {7}
};
6.3 2차원 배열 순회
java
int[][] matrix = {{1, 2, 3}, {4, 5, 6}};

// 중첩 for문
for (int i = 0; i < matrix.length; i++) {           // 행 순회
    for (int j = 0; j < matrix[i].length; j++) {    // 열 순회
        System.out.print(matrix[i][j] + "\t");
    }
    System.out.println();
}

// 향상된 for문
for (int[] row : matrix) {
    for (int element : row) {
        System.out.print(element + "\t");
    }
    System.out.println();
}
7. 배열 사용 시 주의사항
7.1 일반적인 오류들
ArrayIndexOutOfBoundsException
java
int[] arr = new int[3];  // 인덱스 0, 1, 2만 유효
arr[3] = 10;  // 런타임 오류 발생!
NullPointerException
java
int[] arr = null;
System.out.println(arr.length);  // NullPointerException 발생!
타입 불일치
java
int[] arr = new int[3];
arr[0] = "문자열";  // 컴파일 오류!
7.2 안전한 배열 사용법
java
int[] arr = new int[5];

// 안전한 순회
for (int i = 0; i < arr.length; i++) {  // length 사용
    System.out.println(arr[i]);
}

// null 체크
if (arr != null && arr.length > 0) {
    // 배열 사용 로직
}
8. 실무 활용 예제
8.1 학생 성적 관리 시스템
java
import java.util.Scanner;

public class ScoreManager {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        
        // 과목별 점수 저장 배열
        String[] subjects = {"국어", "영어", "수학"};
        int[] scores = new int[subjects.length + 2];  // +2는 총점, 평균용
        
        String name;
        System.out.print("학생명 > ");
        name = scan.next();
        
        int total = 0;
        for (int i = 0; i < subjects.length; i++) {
            System.out.print(subjects[i] + " 점수 > ");
            scores[i] = scan.nextInt();
            total += scores[i];
        }
        
        scores[subjects.length] = total;  // 총점 저장
        scores[subjects.length + 1] = total / subjects.length;  // 평균 저장
        
        // 결과 출력
        System.out.println("학생명\t국어\t영어\t수학\t총점\t평균");
        System.out.print(name + "\t");
        for (int score : scores) {
            System.out.print(score + "\t");
        }
        
        scan.close();
    }
}
9. 핵심 정리
9.1 배열의 핵심 특징
동일한 타입의 데이터만 저장 가능

고정된 크기 - 생성 후 크기 변경 불가

0부터 시작하는 인덱스

참조 타입 - 힙 메모리에 저장

length 속성으로 배열 크기 확인

9.2 성능 고려사항
메모리 효율성: 연속된 메모리 할당으로 캐시 친화적

접근 속도: O(1) 시간복잡도로 빠른 랜덤 접근

복사 성능: System.arraycopy() > Arrays.copyOf() > for문

9.3 모범 사례
배열 크기는 length 속성 활용하여 안전한 순회

타입별 기본값 숙지하여 초기화 전략 수립

적절한 복사 방법 선택 (용도에 따라)

2차원 배열에서는 가변 배열 활용으로 메모리 최적화

null 체크와 경계값 검사로 안전한 코드 작성

배열은 Java 프로그래밍의 기초이자 핵심 자료구조로, 효율적인 데이터 관리와 알고리즘 구현의 토대가 됩니다. 위의 개념들을 숙지하면 더 안전하고 효율적인 Java 프로그램을 작성할 수 있을 것입니다.