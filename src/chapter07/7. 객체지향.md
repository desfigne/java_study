## 7. 객체 지향(Object Oriented)

실생활을 모델링 --------------------> 클래스(class / 틀, 설계도) ------------> 객체(Object)
             추상화(Abstraction)

 1) 클래스
  - 객체를 생성하기 위한 틀, 설계도를 의미
  - 구성은 필드(Field), 생성자(Constructor) / 이름은 생성자지만 메소드이며 한번만 호출됨, 메소드(Method)로 구성됨
  - 클래스의 구성요소는 캡슐화(Encapsulation)를 통해 내용이 보호됨
 
 2) 클래스 구조(형식)
  - class라는 키워드가 붙고, 클래스명(클래스의 이름)
    class 클래스명 {
          // Field : 전역변수 (또는 맴버변수라고도 불림)
          // Constructor : 생성자 메소드 - 객체를 생성할 때 호출되는 메소드, new 키워드 뒤에 선언
          // Method :  기능을 정의하고 호출시 객체명.메소드명 형식으로 호출 (하나의 기능은 하나의 메소드를 권장, 여러개 기능 지양)
          }
  - 접근제어자 : public, private 등
 
 3) 객체
  - 클래스라는 틀을 통해 메모리 Heap에 생성됨
  - 클래스의 생성자를 new라는 키워드에 뒤에 호출하여 생성함

 예) 사자,호랑이, 기린, 코끼리와 같은 동물의 클래스를 도출과 코드를 작성
  - 추상화를 통해 클래스 설계 : 클래스 동물
    동물 is a 사자 - 동물은 사자입니다. > X
    사자(객체) is a 동물(클래스) - 사자는 동물입니다. > O, 앞에는 객체, 뒤에는 클래스
    호랑이(객체) is a 동물(클래스)
    기린(객체) is a 동물(클래스)
    코끼리(객체) is a 동물(클래스)
    
  - 사자의 이름은 심바, 호랑이 이름은 호돌이, 기린은 기린이, 코끼리는 코순이
    사자 has a 이름(심바) - O
    이름(심바) has a 사자 - X
    
  - 사자의 나이는 5, 호랑이 2, 기린은 3, 코끼리 10
    사자 has a 나이:명사 - O
    이름(심바) has a 사자 - X
    사자, 호랑이, 기린, 코끼리는 잠을 잔다. - 메소드
    잠을 잔다 => 사자는 잠을 잔다.

  - 추상화를 통해 클래스 설계 : 클래스 - 동물, 객체 - 사자, 호랑이, 기린, 코끼리
    class 동물{
          // 필드 : 전역변수 - 형식) 데이터 타입 변수명 = 값;
          String 이름;
          int 나이;
          // 생성자
          public 생성자명[클래스명]() { - 생성자명은 클래스명과 동일함, 동일해야 하는 규칙
          	// 생성될 때 실행하는 기능
          }
          // 메소드
          접근제어자 반환타입 메소드명() {
          	// 메소드의 기능 - 잠을 잔다.
          }
    }



예) 동물원 관리 프로그램
사자, 호랑이, 기린, 코끼리..
반복은 제어문 역할, 1:1로 사용시 재사용이 어려워 공통 분모로 묶어 관리하는게 클래스
정확하게 그려지는건 객체, 뚜렷하지 않지만 전체의 공통점을 뽑아내는고 상황에 따라 다르게 뽑아낼 수 있는 추상화

Scanner scan = new Scanner(System.in); new 뒤는 생성자
(앞) Scanner : 객체를 만들기 위한 설계도, 붕어빵 틀
(뒤) Scanner : 실제 매모리에 존재하는 인스턴스(객체/설계도), 실제로 먹게 되는건 붕어빵
 ㄴ 스택에 잡히는 것은 객체라고 하지 않고, 힙에 있는 부분만 객체
 
 기본형으로 잡아도 자바는 객체 지향이기 때문에 실제로는 객체로 정해짐
 예를 들어 int는 Integer라는 객체를 가져옴
 int : integer
 int k = scan.nextInt(); = 뒤는 메소드
 이런 형식은 Wrapper class로 불림
 
 
 
 [실습 예제]
 홍길동씨는 더조은 고등학교의 성적관리 시스템을 담당하고 있다. 홍길동씨는 학생들의 시험 성적이 나오면 학생명, 국어, 영어, 수학 성적을 입력하여 한 번에 한명씩 등록한다. 성적을 수정/삭제하는 경우에는 학생명을 기준으로 검색하여 점수를 수정하거나 삭제를 진행한다.
 
 - 명사, 동사를 도출하여 클래스를 설계해 보세요. // 명사는 클래스, 수치가 명확한 것은 필드 / 동사는 메소드
 
 - 명사 :
 ㄴ 관리자
 ㄴ 학생이름
 ㄴ 점수(과목 별)
   ㄴ 국어
   ㄴ 영어
   ㄴ 수학
 
 - 동사 : 
 ㄴ 성적을 등록한다.
   ㄴ 학생의 이름을 입력한다.
   ㄴ 해당 학생의 국어 점수를 입력한다.
   ㄴ 해당 학생의 영어 점수를 입력한다.
   ㄴ 해당 학생의 수학 점수를 입력한다.
   
 ㄴ 성적을 조회한다.
   ㄴ 학생의 이름을 입력한다.
   ㄴ 해당 학생 이름을 입력한다.
   ㄴ 해당 학생의 과목별 점수와 총합, 평균 수치가 표시된다.
   ㄴ 성적을 수정하거나 삭제한다.
 
 << 개념 설계 >>
 
 [클래스명 : 학생]
 필드 : 학생명, 국어, 영어, 수학
 생성자 : 학생()
 메소드 :
   
 [클래스명 : 성적관리 시스템]
 필드 : 관리자, 학생클래스
 생성자 : 성적관리 시스템() // 괄호 안에 없는건 기본 생성자
 메소드 : 등록한다. 수정한다. 삭제한다. 검색한다.
 
 << 물리적 설계 >>
 
 2 [클래스명 : Student]
 Field : name:String, kor:int, eng:int, math:int
 Constructor : Student()
 Method :
   
 3 [클래스명 : ScoreMgmSystem]
 Field : admin:String, sname:Student
 Constructor : ScoreMgmSystem()
 Method : insert(), update(), remove(), search()
 
 1 [클래스명 : ScoreMgmSystemTest]
 Field : 
 Constructor : 
 Method : main()
 
 
 
 1. 객체 생성
   메인과 사이드 연동
  
 2. 객체 데이터 할당
   실제 수치값은 메인에서,
 
 3. 메소드 호출
   각 데이터 특성은 사이드에서
 
 
    
  4) 생성자 > 객체의 초기화(필드)
  - 클래스를 통해 객체를 생성하는 역할을 진행
  - 객체의 필드(맴버변수)를 초기화하는 작업!!
  - 가장 먼저 호출되는 메소드이며, 딱 한번만 호출됨
  - 기본생성자 생략시 JVM이 자동으로 호출하여 실행됨 (단, 정의된 생성자가 존재하지 않는 경우)
  - 호출위치는 new 생성자();
  - 생성자 이름은 클래스명과 동일
  - 기본 생성자(생성자())는 정의시 생략이 가능함, 단 기본생성자만 존재하는 경우
  - 리턴값이 없으며, 매개변수를 통해 생성자 오버로딩이 가능함
  - 형식 : [접근제어자(필수는 아님, 생략 가능)] [클래스명(필수)](매개변수...) { 초기화 실행문; )

  4-1) this
  - 객체 자기 자신을 참조하는 변수 (이미 정의되어 있는 this이기에 동일한 this 사용 지양)
  - 정의된 메소드(생성자/setter,getter..) 에서 호출 가능
  - this 키워드를 사용하여 명확한 코드 구성을 진행함
  
  4-2) this()
  - 생성자에서 또 다른 생성자를 호출할 때 사용함
  - this() 메소드는 생성자의 가장 선두에 호출되어야 함
  - this() 메소드는 매개변수를 통해 다른 생성자에게 데이터(혹은 주소)를 전달함
  - this() 메소드는 생성자에서만 사용가능
  
  5) 메소드 > 재사용성
  - 객체의 기능을 담당하는 역할
  - 메소드 정의 형식
    접근제어자][리턴타입(반환타입)] 메소드명([매개변수(파라미터)]) {
    메소드의 기능 실행문;
    }
    
    ** 접근제어자 :
       메소드를 호출하는 범위를 정의하는 역할 (누가 가지고 있고 이름이 무엇인지 알고 있으면 누구나 사용 가능)
       공용 사용을 위해 사용하는게 메소드인데 프라이빗은 혼자 쓰기 위한 것이라 대체적으로는 사용하지 않음
       public, private, protected, default(package)
       
    ** 리턴타입(반환타입) : 메소드가 실행을 한 결과를 호출한 곳에 리턴(전달)하는 경우 정의
       리턴값은 return 키워드 뒤에 입력함, 만약 리턴값이 없으면 void를 입력
       예) getNumber() 메소드 호출 시 int 타입의 정수 100을 전달받음 
       public int getNumber() {
       	   return 100; // 리턴타입이 있을 경우 리턴을 필수로 넣어야 함, 안넣으면 에러
       }
       
    ** 매개변수(파라미터) :
       메소드 호출 시 메소드의 기능을 실행하기 위해 필요한 값들을 전달하는 역할
       실행문에서 사용되는 데이터타입을 맞추어 입력을 받아야 함
       매개변수의 갯수는 정해지지 않음 임의로 정의 가능
       매개변수의 데이터타입은 기본형, 참조형 모두 가능함
       예) add(값1, 값2);  값1, 값2를 add 메소드 호출 시 입력받아 실행을 하는 메소드
       add(10, 20); --> 출력 형식 : sum = 30
       public void add(int num1, int num2) { // 이름은 아무렇게나 작성 가능
           Sytem.out.println("sum = " + (num1 + num2));
       }
 
    << / -- !! 중요 !! -- >>
    
    << 리턴타입과 매개변수에 따른 메소드 정의 예 >>
    
(1) 리턴타입 X, 매개변수 X
   public void method1() {
       System.out.println("method1 --> 리턴타입 X, 매개변수 X");
   }
        
   호출 : method1()
   출력 : method1 --> 리턴타입 X, 매개변수 X

(2) 리턴타입 O, 매개변수 X
   public int method2() {
       int num1 = 10;
       int num2 = 20;
       return num1+num2;
   }
        
   호출 : method2()
   리턴값 : 30

(3) 리턴타입 X, 매개변수 O
   public void method3(int num1, int num2) { // 호출하는 메소드에 파라미터 인자로 보내야 함
       System.out.println("method3 --> " + (num1 + num2));
   }
			
   public void method3(String name) {
       System.out.println("method3 --> " + name);
   }
        
   호출 : method3(10, 20); or method3("홍길동");
   리턴값 : method3 --> 30 or method3 --> 홍길동

(4) 리턴타입 O, 매개변수 O
   public int method4(int num1, int num2) {
       return num1 + num2;
   }
			
   public String method4(String name) {
       return name;
   }
        
   호출 : method4(10, 20); or method4("홍길동");
   리턴값 : 30 or 홍길동

   위의 4개는 무조건 완벽히 익혀야 함, 정말 외워서라도 정확히 이해해야 함
   (api를 활용할때 어려움이 없으려면)
   
   << -- !! 중요 !! -- / >>
  
  6) 메소드 오버로딩 (Overloading) // 메소드 오버로딩 실습 파일 참조
  - 하나의 클래스에 동일한 이름을 가진 메소드를 여러개 정의하는 것 (생성자에도 오버로딩이 적용 가능)
  - 단 매개변수의 갯수와 타입은 서로 달라야 함
  - 리턴 타입은 상관 없음
  
  7) 가변 매개변수 (Variable Aguments)
  - 매개변수 입력 시 갯수에 제한없이 동일한 데이터타입으로 입력가능
  - 형식 : 메소드명(데이터타입 ... 변수명) { ~ }
  
  void method(int ... numbers) {} --> 호출 시 : method(1,2,5,76,8,5,9);
  void method(String ... names) {} --> 호출 시 : method("홍길동","hong","smith");
  
  int[] numbers = {1,2,5,76,8,5,9};
  void method(int numbers[]) {} --> method(numbers);
  
  ** 가변 매개변수는 자바스크립트의 스프레드 연산자와 모양은 동일하지만,
     기능이 조금씩 다르므로 정리필요